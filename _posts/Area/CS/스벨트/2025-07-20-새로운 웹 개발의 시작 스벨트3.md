---
title: "LUVIT 새로운 웹 개발의 시작 스벨트3"
date: 2025-07-20
categories: [Book Review, Computer Science]
tags: [스벨트, svelte, software-development, best-practices, frontend]
---

## 들어가며
> 이 포스트는 오시내님의 「LUVIT 새로운 웹 개발의 시작 스벨트」 1장부터 7장까지 읽고 개인적으로 학습한 내용을 정리한 글입니다.
> - 책: LUVIT 새로운 웹 개발의 시작 스벨트
> - 저자: 오시내
> - 출판사: 제이펍
> - 챕터: 11 ~ 10장 

# 핵심 내용 정리

## 11장 스벨트 slot
> slot은 부모 컴포넌트가 자손 컴포넌트에 컨텐츠를 전달하는 기능

- slot의 기본 문법

```javascript
<자손 컴포넌트명>

</자손 컴포넌트명>

<div>
    <slot></slot>
</div>
```

### fallback slot
- fallback : default 값을 가진 slot
- 자식 컴포넌트

```javascript
<div class="box">
    <slot>
        <p>입력된 데이터가 없습니다.</p>
    </slot>
</div>
```

- 부모 컴포넌트

```javascript
<script>
    import Child02 from "./Child02.svelte";
</script>

<Child02>
    <h4>이름 : 스벨트(Svelte)</h4>
    <p>배포 년도 : 2016년</p>
    <img src="https://svelte.dev/favicon.png" alt="스벨트(Svelte)" height="50" />
</Child02>

<Child02>
    <h4>이름 : 리액트(React)</h4>
    <p>배포 년도 : 2013년</p>
    <img src="https://ko.legacy.reactjs.org/favicon.ico" alt="리액트(React)" height="50" />
</Child02>
<Child02></Child02>

```

### slot 이름 설정

- 자식 컴포넌트 : slot에 이름 지정한 예시

```javascript
<div class="box">
    <h4>
        이름 : 
        <slot name="name">
            전달받은 이름이 없습니다.
        </slot>
    </h4>
    <p>
        배포 년도 : 
        <slot name="release">
            전달받은 배포 년도가 없습니다. 
        </slot>
    </p>
</div>
```

- 부모 컴포넌트

```javascript
<script>
    import Child03 from "./Child03.svelte";
</script>

<Child03>
    <span slot="name">스벨트(Svelte)</span>
    <span slot="release">2016</span>
</Child03>

<Child03>
    <span slot="name">리액트(React)</span>
    <span slot="release">2013</span>
</Child03>
<Child03></Child03>
```

### slot props
- slot props : slot 요소가 명시된 하위 컴포넌트의 값을 상위 컴포넌트로 전달할 때 사용
- 자식 컴포넌트

```javascript
<script>
    let hovering;
    const enter = () => hovering = true;
    const leave = () => hovering = false;
</script>
<div class="box">
    <h4 on:mouseenter={enter} on:mouseleave={leave}>
        이름 :
        <slot hovering={hovering}>
            전달받은 이름이 없습니다.
        </slot>
    </h4>
</div>
```

- 부모 컴포넌트

```javascript
<script>
    import Child04 from "./Child04.svelte";
</script>
<Child04 let:hovering={active}>
    <span class:active={active}>스벨트(Svelte)</span>
</Child04>
<Child04 let:hovering={active}>
    <span class:active={active}>리액트(React)</span>
</Child04>
```

### 조건 slot

```javascript
{#if $$slots.name && $$slots.release}
<div class="box">
    <h4>
        이름 : <slot name="name"></slot>
    </h4>
    <p>
        배포 년도 : <slot name="release"></slot>
    </p>
</div>
{/if}
```

## 12장 라이프 사이클
### onMount 
- onMount 함수는 컴포넌트가 DOM에 마운트(구현)되면 실행

```javascript
<script>
    import { onMount } from 'svelte';
  
    let comments = [];
  
    onMount(async () => {
      const res = await fetch(`https://jsonplaceholder.typicode.com/comments?_limit=21`);
      comments = await res.json();
    });
  </script>
  <h3>회원 정보</h3>
  
  <div class="comments">
    {#each comments as comment}
      <article>
        <h4>이름 : {comment.name}</h4>
        <h4>이메일 주소 : {comment.email}</h4>
      </article>
    {:else}
      <!-- comments의 배열 데이터 개수가 0개인 경우(불러오는 중) -->
      <p>loading...</p>
    {/each}
  </div>
```

### onDestory
- onDestory : 컴포넌트가 제거될 때 호출

```javascript
<script>
    import { onMount, onDestroy } from 'svelte'; 

    onMount(() => {
        console.log('onMount()실행');
    });

    onDestroy(() => {
        console.log('onDestroy()실행');
    });
</script>

<div>
    <h3>자손 컴포넌트</h3>
</div>
```

### beforeUpdate & afterUpdate 
- beforeUpdate : DOM이 업데이트 되기 직전에 호출되는 라이프 사이클 함수
- afterUpdate : DOM이 업데이트 직후 호출되는 라이프 사이클 함수

```javascript
<script>
    import { beforeUpdate, afterUpdate } from 'svelte';

    let num = 0;

    beforeUpdate(() => {
        console.log('업데이트가 실행되기 전...');
    });
    afterUpdate(() => {
        console.log('업데이트 완료!');
    });

    const handleClick = () => {
        num++;
    }
</script>

<button on:click={handleClick}>숫자 증가</button>
<p>현재 숫자: {num}</p>

```

### tick 함수
- tick 
    - 언제든지 사용할 수 있는 함수(마운트, 언마운트 모두)
    - tick 함수는 변경된 내용이 있을 경우, 변경된 내용이 DOM에 반영된 지궇에 호출
    - tick 함수가 컴포넌트 또는 element에 적용되면 Promise 객체 반환

```javascript
<script>
    import { tick } from 'svelte';

    let isElementView = false;
    let input;

    const handleClick = (param) => {
        isElementView = param;
        if(isElementView === true) {
            tick().then(() => input.focus());
        }
    }
</script>

<button on:click={() => handleClick(true)}>input 활성화</button>
<button on:click={() => handleClick(false)}>input비 활성화</button>
{#if isElementView}
    <div>
        <input type="text" bind:this={input} />
    </div>
{/if}
```

## 13장 context API
- context API
    - 최상위 컴포넌트에서 전달하려는 데이터를 콘텍스트 영역에 추가한 후, 자식 컴포넌트들이 이 영역에 접근해 데이터를 사용하는 방식
    - 사실상 컴포넌트단의 전역 변수

- props drilling 
    - 여러 컴포넌트에 Props를 계속 전달하는 과정 => 비효율적

### Context API 기본 사용 법
- setContext : Context에 데이터를 추가하는 함수, 매개 변수에 키와 값을 쌍으로 작성해야함
- getContext : Context에 데이터를 가져오는 함수, 키를 매개변수로 전달해 데이터를 가져옴

```javascript
<script>
    import { setContext, getContext } from "svelte";
    import ContextFather from "./ContextFather.svelte";

    setContext('num',1);
    let num = getContext('num');
</script>

<div>
    <h1>Grand 구역</h1>
    <button on:click={() => num++}>1씩 증가</button>
    <p>기본 숫자 : { num }</p>
    <hr />
    <ContextFather />
</div>
```

### dispatch
- dispatch
    - 이벤트 전달을 위한 방법
    - 하위 컴포넌트에서 생성한 이벤트 함수를 상위 컴포넌트에서 사용할 수 있게 함

- dispatch 예시
- 최하위 컴포넌트

```javascript
<script>
    import { createEventDispatcher } from 'svelte'

    const dispatch = createEventDispatcher();

    const addAction = param => {
        dispatch('add', {
            value : param,
            message: param + ' 값 추가'
        });
    }
</script>
    
<button on:click={() => addAction(1)} >1씩 증가</button>
<button on:click={() => addAction(2)} >2씩 증가</button>
```
- 중간 컴포넌트

```javascript
<script>
    import DispatchChild from "./DispatchChild.svelte";
</script>
  
<DispatchChild on:add />
```
- DispatchChild on:add를 통해 add인 dispatch를 전달해야함

- 최상위 컴포넌트

```javascript
<script>
    import DispatchParent from "./DispatchParent.svelte";

    let num = 0;

    const handleValueAdd = e => {
        console.log(e.detail.message);
        num = num + e.detail.value;
    }
</script>

<p>num : {num}</p> 

<DispatchParent on:add={handleValueAdd}  />
```

## 14장 Store
- Store 
    - 전역에서 데이터를 전달받고 싶거나, 데이터 변경을 요청 시 사용
    - Vuejs의 Vuex와 동일


### writable 스토어
- writable 스토어 기본 문법

```javascript
import {writable} from 'svelte/store';
export const storeName = writable(defaultValue);

// markup
{ $storeName}
```

- get : 값 가져오기
- set : 값 초기화
- update : 값 수정
- subscribe : 값을 반응성 형태로 조회

### readable 스토어
- readable 스토어 
    - 읽기만 가능한 스토어
    - 현재 시간, 사용자 위치, 마우스 위치 등 수정이 필요하지 않은 스토어 선언 시 사용
    - 스토어는 js 파일로 생성 -> 컴포넌트가 아님

- readable 스토어 예시

```javascript
import { readable } from 'svelte/store';

export const time = readable(new Date(), function start(set) {
	const interval = setInterval(() => {
		set(new Date());
	}, 1000);

	return function stop() {
		clearInterval(interval);
	};
});
```

### derived 스토어
- derived 스토어
    - 기존의 스토어값에서 파생된 값을 가공해 사용할 수 있게 해주는 기능

- derived 스토어 예시

```javascript
import { readable, derived } from 'svelte/store';

export const time = readable(new Date(), function start(set) {
	const interval = setInterval(() => {
		set(new Date());
	}, 1000);

	return function stop() {
		clearInterval(interval);
	};
});

const start = new Date(); 

export const elapsed = derived(time, ($time) => Math.round(($time - start) / 1000));
```

### custom 스토어
- custom 스토어
    - 개발자가 custom한 스토어

``` javascript
import { writable } from 'svelte/store';

const createCount = () => {
  const { subscribe, set, update } = writable(0);

  return {
    subscribe,
    increment: () => update(n => n + 1),
    decrement: () => update(n => n - 1),
    reset: () => set(0)
  };
}

export const count = createCount();
```

## 15장 스벨트 CSS 제어
### 스벨트 css 기본 사용법
- 스벨트 css 기본 사용법 얘시

```javascript
<script>
    let color01 = 'pink';
</script>

<h1>제목 태그1</h1>
<h2 class="title02">제목 태그2</h2>
<h3 style="color: {color01}">{color01}</h3>

<style>
    h1{ background-color: black; color: pink; }
    .title02{ background-color: black; color: yellow; }
</style>
```

### class:지시문
- class:지시문을 통한 상탯값과 연동해 콘텐츠를 제어하는 방법

```javascript
<script>
    let current = 'first';
</script>

<button class:active={current === 'first'} on:click={() => current = 'first'}>첫 번째 버튼</button>
<button class:active={current === 'second'} on:click={() => current = 'second'}>두 번째 버튼</button>
<button class:active={current === 'third'} on:click={() => current = 'third'}>세 번째 버튼</button>

<style>
    button{
        border: none; border-radius: 5px; background-color: #ededed; 
        padding: 5px 20px; cursor: pointer;
    }
    button::after{ content: ' - 비활성'; }
    .active{
        background-color: cornflowerblue; color: white;
    }
    .active::after{ content: ' - 활성'; }
</style>
```

### rollup을 통한 Sass 플러그인 설치
- rollup
    - webpack과 같은 bundler
- Sass 적용하기

## 16장 스벨트 트랜지션
### transition: 지시문
- transition: 기본 문법

```javascript
<script>
</script>
    import {transitionName} from 'svelte/transition';
<tag element transition:transitionName={parameter}/>
```

|트랜지션명|설명|
|------|---|
|fade| 요소의 투명도를 통한 애니메이션화|
|blur| 요소의 불투명도와 함께 흐림필터를 애니메이션에 적용|
|slide|요소를 상단 혹은 좌측 기준으로 나타나거나 사라지게 함|
|scale|요소의 불투명도와 크기에 애니메이션을 적용|
|fly|요소의 x,y 위치와 불투명도에 애니메이션을 전환|
|draw| SVG 요소에 애니메이션을 적용|
|crossfade|두 개의 요소 간 화면전환 효과 적용|

### 페이드 효과
- 페이드 효과 예시(in,out 적용)

```javascript
<script>
	import { fade } from 'svelte/transition';
	let visible = false;
</script>

<label>
	<input type="checkbox" bind:checked={visible} /> 보임
</label>

{#if visible}
	<p 
        in:fade={{ duration: 400 }}
        out:fade={{ duration: 0 }}
    >Svelte Fade Effect</p>
{/if}

<style>
    p{ height: 100px; background-color: orange; }
</style>
```

### 블러 효과
- 블러 효과 예시(in,out적용)

```javascript
<script>
	import { blur } from 'svelte/transition';
	let visible = false;
</script>

<label>
	<input type="checkbox" bind:checked={visible} /> 보임
</label>

{#if visible}
	<p
        in:blur={{ amount: 20 }}
        out:blur={{ amount: 0 }}
    >Svelte Blur Effect</p>
{/if}

<style>
    p{ height: 100px; background-color: orange; }
</style>
```
- blur 파라미터 종류

|파라미터명|설명|
|------|---|
|delay| 효과를 지연시키는 속성, 기본값은 0, 숫자값으로 작성, ms단위|
|duration| 변화가 일어나는 시간, 기본값은 400, 숫자값으로작성, ms단위|
|easing| 변화에 속도감을 주는 속성, easing 함수명으로 작성, 기본값은 cubicInOut|
|opacity| 애니메이션의 투명도 값을 지정, 기본값은 0|
|amount|blur의 번짐 크기를 지정,기본값은 5|

### 슬라이드 효과
- 슬라이드 효과 : 상단 혹은 좌측 기준으로 요소를 나타나거나 사라지게 함
- 슬라이드 효과 예시(in,out 적용)

```javascript
<script>
	import { slide } from 'svelte/transition';
	let visible = false;
</script>

<label>
	<input type="checkbox" bind:checked={visible} /> 보임
</label>

{#if visible}
	<p
        in:slide={{ axis: 'y' }}
        out:slide={{ axis: 'x' }}
    >Svelte Slide Effect</p>
{/if}

<style>
    p{ height: 100px; background-color: orange; }
</style>
```

### 스케일 효과
- 스케일 효과 : 요소의 불투명도와 크기를 애니메이션에 적용
- 스케일 효과 예시(in,out 적용)

```javascript
<script>
	import { scale } from 'svelte/transition';
	let visible = false;
</script>

<label>
	<input type="checkbox" bind:checked={visible} /> 보임
</label>

{#if visible}
	<p
        in:scale={{ start: 0 }}
        out:scale={{ start: 0.5 }}
    >Svelte Scale Effect</p>
{/if}

<style>
    p{ height: 100px; background-color: orange; }
</style>
```

### 플라이 효과
- 플라이 효과: 요소의 x,y 위치와 불투명도를 조정하는 애니메이션 효과
- 플라이 효과 예시(in,out 적용)

```javascript
<script>
	import { fly } from 'svelte/transition';
	let visible = false;
</script>

<label>
	<input type="checkbox" bind:checked={visible} /> 보임
</label>

{#if visible}
	<p
        in:fly={{ y: 200 }}
        out:fly={{ y: 0 }}
    >Svelte Fly Effect</p>
{/if}

<style>
    p{ width: 100px; height: 100px; background-color: orange; }
</style>
```

    
